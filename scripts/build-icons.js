const fs = require('fs-extra');
const path = require('path');
const { optimize } = require('svgo');

const iconsDir = path.join(__dirname, '../src/icons');
const componentsDir = path.join(__dirname, '../src/components');
const svgoConfig = require('../svgo.config');

async function buildIcons() {
  try {
    // Ensure components directory exists
    await fs.ensureDir(componentsDir);
    
    // Clear existing components
    await fs.emptyDir(componentsDir);
    
    const iconExports = [];
    
    // Read all SVG files from icons directory
    const svgFiles = await fs.readdir(iconsDir);
    const svgFilesFiltered = svgFiles.filter(file => file.endsWith('.svg'));
    
    console.log(`Found ${svgFilesFiltered.length} SVG files`);
    
    for (const file of svgFilesFiltered) {
      try {
        const filePath = path.join(iconsDir, file);
        const svgCode = await fs.readFile(filePath, 'utf8');
        
        // Generate component name from filename
        const baseName = path.basename(file, '.svg');
        
        // Create descriptive component name with all meaningful words (version 1.6.0 style)
        const componentName = `Icon${baseName
          .split(/[,\s-]+/)
          .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
          .join('')}`;
        
        console.log(`Processing: ${file} -> ${componentName}`);
        
        // Optimize SVG with SVGO while preserving stroke attributes
        const result = optimize(svgCode, svgoConfig);
        let optimizedSvg = result.data;
        
        // Extract the inner content (everything between <svg> tags)
        const innerContentMatch = optimizedSvg.match(/<svg[^>]*>([\s\S]*)<\/svg>/);
        const innerContent = innerContentMatch ? innerContentMatch[1] : '';
        
        // Detect if the original SVG has stroke-width attribute
        const hasOriginalStrokeWidth = /stroke-width=["']([^"']+)["']/.test(svgCode);
        const originalStrokeWidthMatch = svgCode.match(/stroke-width=["']([^"']+)["']/);
        const originalStrokeWidth = originalStrokeWidthMatch ? originalStrokeWidthMatch[1] : null;
        
        // Generate React component with preserved stroke attributes
        const reactComponent = `import React from 'react';

interface IconProps extends React.SVGProps<SVGSVGElement> {
  size?: number;
  color?: string;
  strokeWidth?: number;
}

export const ${componentName}: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  strokeWidth = ${originalStrokeWidth || '1'},
  ...props
}) => (
  <svg
    {...props}
    width={size}
    height={size}
    viewBox="0 0 24 24"
    fill="none"
    stroke={color}
    strokeWidth={strokeWidth}
    strokeLinecap="round"
    strokeLinejoin="round"
    xmlns="http://www.w3.org/2000/svg"
  >
    ${innerContent}
  </svg>
);
`;
        
        await fs.writeFile(path.join(componentsDir, `${componentName}.tsx`), reactComponent, 'utf8');
        iconExports.push(componentName);
        console.log(`✅ Generated: ${componentName}`);
        
      } catch (error) {
        console.error(`❌ Error processing ${file}:`, error);
      }
    }
    
    // Generate index.ts file
    const indexContent = `// Auto-generated icon exports
// This file is automatically generated by scripts/build-icons.js
// Do not edit manually

${iconExports.map(name => `export { ${name} } from './${name}';`).join('\n')}

// Available Icons:
${iconExports.map(name => `//   ${name}`).join('\n')}

// Usage:
// import { ${iconExports.slice(0, 3).join(', ')} } from 'kruti-icon-library';
// Control size: <${iconExports[0]} size={16} /> <${iconExports[0]} size={20} /> <${iconExports[0]} size={32} />
`;

    await fs.writeFile(path.join(componentsDir, 'index.ts'), indexContent, 'utf8');
    
    console.log(`\n✅ Icons built successfully into ${componentsDir}`);
    console.log(`✅ Generated ${iconExports.length} icons`);
    
  } catch (error) {
    console.error('❌ Build failed:', error);
    process.exit(1);
  }
}

buildIcons();
