const fs = require('fs-extra');
const path = require('path');
const { optimize } = require('svgo');

const iconsDir = path.join(__dirname, '../src/icons');
const componentsDir = path.join(__dirname, '../src/components');
const svgoConfig = require('../svgo.config');

async function buildIcons() {
  try {
    // Ensure components directory exists
    await fs.ensureDir(componentsDir);
    
    // Clear existing components
    await fs.emptyDir(componentsDir);
    
    const iconExports = [];
    
    // Read all SVG files from icons directory
    const svgFiles = await fs.readdir(iconsDir);
    const svgFilesFiltered = svgFiles.filter(file => file.endsWith('.svg'));
    
    console.log(`Found ${svgFilesFiltered.length} SVG files`);
    
    for (const file of svgFilesFiltered) {
      try {
        const filePath = path.join(iconsDir, file);
        const svgCode = await fs.readFile(filePath, 'utf8');
        
        // Generate component name from filename
        const baseName = path.basename(file, '.svg');
        
        // Create simple component name with better logic
        let componentName = 'Icon';
        const words = baseName.split(/[,\s-]+/);
        
        // Build a meaningful name from key words
        const keyWords = [];
        for (const word of words) {
          const cleanWord = word.trim().toLowerCase();
          if (cleanWord && cleanWord !== 'icon' && cleanWord !== 'svg' && 
              cleanWord !== '1' && cleanWord !== '2' && cleanWord !== '3' &&
              cleanWord !== 'large' && cleanWord !== 'big' && cleanWord !== 'small') {
            keyWords.push(word.charAt(0).toUpperCase() + word.slice(1).toLowerCase());
          }
        }
        
        // Take first 2-3 meaningful words to create unique names
        if (keyWords.length >= 2) {
          componentName += keyWords.slice(0, 2).join('');
        } else if (keyWords.length === 1) {
          componentName += keyWords[0];
        } else {
          // Fallback: use first word
          componentName += words[0].charAt(0).toUpperCase() + words[0].slice(1).toLowerCase();
        }
        
        // Handle duplicates by adding a counter suffix
        let finalComponentName = componentName;
        let counter = 1;
        while (iconExports.includes(finalComponentName)) {
          finalComponentName = `${componentName}${counter}`;
          counter++;
        }
        
        console.log(`Processing: ${file} -> ${finalComponentName}`);
        
        // Optimize SVG with SVGO while preserving stroke attributes
        const result = optimize(svgCode, svgoConfig);
        let optimizedSvg = result.data;
        
        // Extract the inner content (everything between <svg> tags)
        const innerContentMatch = optimizedSvg.match(/<svg[^>]*>([\s\S]*)<\/svg>/);
        const innerContent = innerContentMatch ? innerContentMatch[1] : '';
        
        // Detect if the original SVG has stroke-width attribute
        const hasOriginalStrokeWidth = /stroke-width=["']([^"']+)["']/.test(svgCode);
        const originalStrokeWidthMatch = svgCode.match(/stroke-width=["']([^"']+)["']/);
        const originalStrokeWidth = originalStrokeWidthMatch ? originalStrokeWidthMatch[1] : null;
        
        // Generate React component with preserved stroke attributes
        const reactComponent = `import React from 'react';

interface IconProps extends React.SVGProps<SVGSVGElement> {
  size?: number;
  color?: string;
  strokeWidth?: number;
}

export const ${finalComponentName}: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  strokeWidth = ${originalStrokeWidth || '1'},
  ...props
}) => (
  <svg
    {...props}
    width={size}
    height={size}
    viewBox="0 0 24 24"
    fill="none"
    stroke={color}
    strokeWidth={strokeWidth}
    strokeLinecap="round"
    strokeLinejoin="round"
    xmlns="http://www.w3.org/2000/svg"
  >
    ${innerContent}
  </svg>
);
`;
        
        await fs.writeFile(path.join(componentsDir, `${finalComponentName}.tsx`), reactComponent, 'utf8');
        iconExports.push(finalComponentName);
        console.log(`✅ Generated: ${finalComponentName}`);
        
      } catch (error) {
        console.error(`❌ Error processing ${file}:`, error);
      }
    }
    
    // Generate index.ts file
    const indexContent = `// Auto-generated icon exports
// This file is automatically generated by scripts/build-icons.js
// Do not edit manually

${iconExports.map(name => `export { ${name} } from './${name}';`).join('\n')}

// Available Icons:
${iconExports.map(name => `//   ${name}`).join('\n')}

// Usage:
// import { ${iconExports.slice(0, 3).join(', ')} } from 'kruti-icon-library';
// Control size: <${iconExports[0]} size={16} /> <${iconExports[0]} size={20} /> <${iconExports[0]} size={32} />
`;

    await fs.writeFile(path.join(componentsDir, 'index.ts'), indexContent, 'utf8');
    
    console.log(`\n✅ Icons built successfully into ${componentsDir}`);
    console.log(`✅ Generated ${iconExports.length} icons`);
    
  } catch (error) {
    console.error('❌ Build failed:', error);
    process.exit(1);
  }
}

buildIcons();
