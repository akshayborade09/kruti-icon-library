const fs = require('fs-extra');
const path = require('path');
const svgr = require('@svgr/core').transform;
const svgoConfig = require('../svgo.config');

const iconsDir = path.join(__dirname, '../src/icons');
const outDir = path.join(__dirname, '../src/components');

// Function to convert filename to component name
function filenameToComponentName(filename) {
  // Remove .svg extension
  const nameWithoutExt = filename.replace('.svg', '');
  
  // Take only the first part before comma (main name)
  const mainName = nameWithoutExt.split(',')[0].trim();
  
  // Convert to PascalCase
  const pascalCase = mainName
    .split(/[\s-_]+/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
  
  return `Icon${pascalCase}`;
}

// Function to recursively find all SVG files
async function findSvgFiles(dir) {
  const files = [];
  const items = await fs.readdir(dir);
  
  for (const item of items) {
    const fullPath = path.join(dir, item);
    const stat = await fs.stat(fullPath);
    
    if (stat.isDirectory()) {
      const subFiles = await findSvgFiles(fullPath);
      files.push(...subFiles);
    } else if (item.endsWith('.svg')) {
      files.push(fullPath);
    }
  }
  
  return files;
}

// Function to create React component from SVG content
function createReactComponent(svgContent, componentName) {
  // Extract viewBox from original SVG
  const viewBoxMatch = svgContent.match(/viewBox="([^"]+)"/);
  const viewBox = viewBoxMatch ? viewBoxMatch[1] : '0 0 24 24';

  // Extract all path elements and their attributes
  const pathMatches = svgContent.match(/<path[^>]*\/?>/g) || [];
  const paths = [];

  for (const pathMatch of pathMatches) {
    // Extract the path data and other attributes
    const pathDataMatch = pathMatch.match(/d="([^"]+)"/);
    const strokeWidthMatch = pathMatch.match(/stroke-width="([^"]+)"/);
    const strokeLinecapMatch = pathMatch.match(/stroke-linecap="([^"]+)"/);
    const strokeLinejoinMatch = pathMatch.match(/stroke-linejoin="([^"]+)"/);
    
    if (pathDataMatch) {
      let pathElement = `<path d="${pathDataMatch[1]}"`;
      
      // Preserve original stroke attributes if they exist
      if (strokeWidthMatch) {
        pathElement += ` strokeWidth="${strokeWidthMatch[1]}"`;
      }
      if (strokeLinecapMatch) {
        pathElement += ` strokeLinecap="${strokeLinecapMatch[1]}"`;
      }
      if (strokeLinejoinMatch) {
        pathElement += ` strokeLinejoin="${strokeLinejoinMatch[1]}"`;
      }
      
      pathElement += ' />';
      paths.push(pathElement);
    }
  }

  const pathsContent = paths.join('\n    ');

  return `import React from 'react';

interface IconProps extends React.SVGProps<SVGSVGElement> {
  size?: number;
  color?: string;
  strokeWidth?: number;
}

export const ${componentName}: React.FC<IconProps> = ({
  size = 24,
  color = 'currentColor',
  strokeWidth = 2,
  ...props
}) => (
  <svg
    width={size}
    height={size}
    viewBox="${viewBox}"
    fill="none"
    stroke={color}
    strokeWidth={strokeWidth}
    strokeLinecap="round"
    strokeLinejoin="round"
    {...props}
  >
    ${pathsContent}
  </svg>
);
`;
}

(async () => {
  await fs.ensureDir(outDir);

  const svgFiles = await findSvgFiles(iconsDir);
  console.log(`Found ${svgFiles.length} SVG files to process...`);

  for (const svgPath of svgFiles) {
    try {
      const svgCode = await fs.readFile(svgPath, 'utf8');
      const fileName = path.basename(svgPath);
      const componentName = filenameToComponentName(fileName);

      // Create React component manually to preserve stroke attributes
      const componentCode = createReactComponent(svgCode, componentName);

      await fs.writeFile(path.join(outDir, `${componentName}.tsx`), componentCode, 'utf8');
      console.log(`âœ… Generated: ${componentName}`);
    } catch (error) {
      console.error(`âŒ Error processing ${svgPath}:`, error);
    }
  }

  // Generate index file
  const componentFiles = await fs.readdir(outDir);
  const components = componentFiles
    .filter(file => file.endsWith('.tsx'))
    .map(file => file.replace('.tsx', ''));

  const indexContent = `// Auto-generated icon exports
// This file is automatically generated by scripts/build-icons.js
// Do not edit manually

${components.map(comp => `export { ${comp} } from './${comp}';`).join('\n')}

// Available Icons:
${components.map(comp => `//   ${comp}`).join('\n')}

// Usage:
// import { IconArrowLeft, IconMagnifyingGlass2, IconSettingsGear1 } from 'kruti-icon-library';
// Control size: <IconArrowLeft size={16} /> <IconArrowLeft size={20} /> <IconArrowLeft size={32} />
// Control stroke: <IconArrowLeft strokeWidth={1} /> <IconArrowLeft strokeWidth={3} />
`;

  await fs.writeFile(path.join(outDir, 'index.ts'), indexContent);

  console.log(`\nðŸŽ‰ Successfully generated ${components.length} icon components!`);
  console.log(`ðŸ“¦ Components exported from: src/components/index.ts`);
})();
